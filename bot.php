<?php

include __DIR__ . '/vendor/autoload.php';

use Discord\Discord;
use Discord\Builders\MessageBuilder;
use Discord\Builders\CommandBuilder;
use Discord\Parts\Embed\Embed;
use Discord\Parts\Interactions\Interaction;
use Discord\Parts\Interactions\Command\Option;
use Discord\Parts\Interactions\Command\Choice;
use Discord\WebSockets\Intents;

$token = json_decode(file_get_contents('./config.json'), true)['token'];
$discord = new Discord([
	'token' => $token,
	'intents' => Intents::getDefaultIntents()
]);

// Color format regexes
$hex_regex = '/^#(?:[0-9a-fA-F]{3}){2}$/';
$short_hex_regex = '/^#(?:[0-9a-fA-F]{3}){1}$/';
$rgb_regex = '/rgb\((-?\d{1,3}), (-?\d{1,3}), (-?\d{1,3})\)/';

// Generation algorithm variables
enum GenerationAlgorithms
{
	case DarkenLighten;
	case ContrastingColor;
	case PrideFlag;
}

$color_multiplier = 12; // In the DL algorithm, each color is generated by adding/subtracting this value from each of the RGB values of the previous step
$number_of_colors = 7; // The number of colors can optionally be defined in the command - this value is taken as the default
$contrasting_color_multiplier = 2 * $color_multiplier; // In the COM algorithm, this value is subtracted from each of the RGB values of the contrasting color to darken in

$pride_flags = [
	'bisexual_flag' => ['#d50270', '#9b4f96', '#0138a8'],
	'transgender_flag' => ['#5bcdf9', '#f4a9b8', '#fefefe', '#f4a9b8', '#5bcdf9'],
	'pansexual_flag' => ['#fe218c', '#fed701', '#21b1fe'],
	'lesbian_flag' => ['#d52c01', '#ee7527', '#fe9857', '#fefefe', '#d061a7', '#b65591', '#a50262'],
	'mlm_flag' => ['#078d70', '#26cdaa', '#99e7c1', '#fefefe', '#7bade2', '#5049ca', '#3e1a78']
];
$default_pride_flag = array_key_first($pride_flags);

// Palette image variables
$image_width = 1000;
$image_height = 600;

$watermark_width = ($image_width / 4.9);
$watermark_position_x = (($image_width / 2) - ($watermark_width / 2));
$watermark_position_y = (0 + ($image_height * 0.025));

$text_color_switch_threshold = 382; // The hexcode text changes color from white to black if the (R + G + B) value is higher than this value

// Error messages
$error_messages = [
	'wrong_color_format' => 'The provided color (`{$color}`) isn\'t in the correct format.' . PHP_EOL . 'Accepted formats are:' . PHP_EOL . '- hexcode (`#abc123`), ' . PHP_EOL . '- shorthand hexcode (`#f62`), ' . PHP_EOL . '- RGB values (`rgb(0, 122, 255)`).',
	'even_number_of_colors' => 'The `number_of_colors` parameter must be odd. The current provided value is `{$number_of_colors}`.',
	'low_number_of_colors' => 'The`number_of_colors` parameter must be at least 3. The current provided value is `{$number_of_colors}`.',
	'high_number_of_colors' => 'The`number_of_colors` parameter must be at most 21. The current provided value is `{$number_of_colors}`.',
	'incorrect_rgb_range' => 'The RGB values supplied must all be between 0 and 255. The supplied RGB values were `{$rgb_values}`.'
];

// Registering the Discord slash commands - should only be ran once when changes are made to the commands
function createCommands()
{

	global $discord;
	global $number_of_colors;
	global $pride_flags, $default_pride_flag;

	// Darken-Lighten Algorithm
	$discord->application->commands->save(
		$discord->application->commands->create(
			CommandBuilder::new()
				->setName('generate-dl')
				->setDescription('Using the darken-lighten algorithm, generate a color palette based on a given color!')
				->addOption(
					(new Option($discord))
						->setName('color')
						->setDescription('The color to generate a palette around.')
						->setType(Option::STRING)
						->setRequired(true)
				)
				->addOption(
					(new Option($discord))
						->setName('number_of_colors')
						->setDescription('The number of colors the palette should include. By default ' . $number_of_colors . '.')
						->setType(Option::INTEGER)
				)
				->toArray()
		)
	);

	// Contrasting Color algorithm
	$discord->application->commands->save(
		$discord->application->commands->create(
			CommandBuilder::new()
				->setName('generate-con')
				->setDescription('Using the constrating color algorithm, generate a color palette based on a given color!')
				->addOption(
					(new Option($discord))
						->setName('color')
						->setDescription('The color to generate a palette around.')
						->setType(Option::STRING)
						->setRequired(true)
				)
				->addOption(
					(new Option($discord))
						->setName('number_of_colors')
						->setDescription('The number of colors the palette should include. By default ' . $number_of_colors . '.')
						->setType(Option::INTEGER)
				)
				->toArray()
		)
	);

	// Pride Flag algorithm

	// The option needs to be defined outside of the builder because of the foreach loop
	$pride_flag_option = new Option($discord);
	$pride_flag_option->setName('pride_flag');
	$pride_flag_option->setDescription('Choose the pride flag the color pallete should replicate. By default ' . $default_pride_flag . '.');
	$pride_flag_option->setType(Option::STRING);

	foreach (array_keys($pride_flags) as &$flag) {

		$pride_flag_option->addChoice(
			(new Choice($discord))
				->setName($flag)
				->setValue($flag)
		);

	}

	$discord->application->commands->save(
		$discord->application->commands->create(
			CommandBuilder::new()
				->setName('generate-pride')
				->setDescription('Using the pride flag algorithm, generate a color palette based on a given color!')
				->addOption(
					(new Option($discord))
						->setName('color')
						->setDescription('The color to generate a palette around.')
						->setType(Option::STRING)
						->setRequired(true)
				)
				->addOption(
					$pride_flag_option
				)
				->toArray()
		)
	);

}

// Clamp a number to the 0 - 255 range
function clampColorValue($value)
{
	return max(0, min(255, $value));
}

// Transform a hexcode into an array of RGB values
function hexToRGB($hex)
{

	$color = ltrim($hex, '#');
	$r = hexdec(substr($color, 0, 2));
	$g = hexdec(substr($color, 2, 2));
	$b = hexdec(substr($color, 4, 2));

	return [$r, $g, $b];

}

// Transform shorthand hexcode into longform hexcode (e.g. #f60 -> #ff6600)
function interpretShorthandHexcode($shorthand_hexcode)
{

	$chars = str_split($shorthand_hexcode);
	$hexcode = [];

	// Add the # as the first character
	array_push($hexcode, '#');

	// Go through each character of the shorthand code, starting from the 2nd one (as the 1st one is the #), and double each of them
	for ($i = 1; $i < count($chars); $i++) {
		for ($j = 0; $j < 2; $j++) {
			array_push($hexcode, $chars[$i]);
		}
	}

	$hexcode = join($hexcode);

	return $hexcode;

}

// Transform any allowed color format into a standard hexcode
function normalizeColorFormat($color)
{

	global $hex_regex, $short_hex_regex, $rgb_regex;

	// The color already is a hexcode
	if (preg_match($hex_regex, $color)) {
		return $color;
	}

	// The color is a shortform hexcode
	if (preg_match($short_hex_regex, $color)) {
		return interpretShorthandHexcode($color);
	}

	// The color is given in RGB values
	if (preg_match($rgb_regex, $color)) {
		$color_rgb = explode(', ', rtrim(ltrim($color, 'rgb('), ')')); // Isolate the values and split them into an array
		return sprintf("#%02x%02x%02x", $color_rgb[0], $color_rgb[1], $color_rgb[2]); // Transform the RGB values into a hexcode
	}

}

// Generate a palette using the Darken-Lighten algorithm
// With this algorithm, each color step adds/subtracts a certain constant number from each three of the RGB values of the original color
function generateDarkenLightenPalette($color, $number_of_colors)
{

	global $color_multiplier;
	$color_palette = [];

	$color_rgb = hexToRGB($color);

	// The for loop should include the given number of colors and have the index 0 be in the middle
	// E.g. a number of colors value of 5 should lead into a for loop of -2 .. 2
	$for_index = ($number_of_colors - 1) / 2;

	for ($i = -$for_index; $i <= $for_index; $i++) {

		$new_color_rgb = [];
		for ($j = 0; $j <= 2; $j++) {
			$new_color_rgb[$j] = clampColorValue($color_rgb[$j] + ($i * $color_multiplier)); // Multiply each RGB value by the multiplier
		}

		$new_color_hex = sprintf("#%02x%02x%02x", $new_color_rgb[0], $new_color_rgb[1], $new_color_rgb[2]); // Transform the RGB values into a hexcode
		array_push($color_palette, $new_color_hex);

	}

	return $color_palette;

}

// Generate a palette using the Constraing Color algorithm
// With this algorithm, the first (number_of_colors - 2) colors are generated using the Darken-Lighten algorithm
// The last 2 colors are generated as a contrasting color and its darker version
function generateContrastingColorPalette($color, $number_of_colors)
{

	global $color_multiplier, $contrasting_color_multiplier;
	$color_palette = [];

	$dl_palette = generateDarkenLightenPalette($color, $number_of_colors);

	// Use the center colors of the DL palette as the starting colors off the CON palette
	for ($i = 1; $i < count($dl_palette) - 1; $i++) {
		array_push($color_palette, $dl_palette[$i]);
	}

	$color_rgb = hexToRGB($color);

	// Calculate the contrasting color by looking at the opposite side of the color wheel
	$secondary_color_rgb = [];
	for ($j = 0; $j <= 2; $j++) {
		$secondary_color_rgb[$j] = (255 - $color_rgb[$j]);
	}

	$secondary_hex = sprintf("#%02x%02x%02x", $secondary_color_rgb[0], $secondary_color_rgb[1], $secondary_color_rgb[2]); // Transform the RGB values into a hexcode
	array_push($color_palette, $secondary_hex);

	// Calculate the darker version of the contrasting color
	$secondary_multiplied_rgb = [];
	for ($j = 0; $j <= 2; $j++) {
		$secondary_multiplied_rgb[$j] = clampColorValue($secondary_color_rgb[$j] - ($contrasting_color_multiplier));
	}
	$secondary_multiplied_hex = sprintf("#%02x%02x%02x", $secondary_multiplied_rgb[0], $secondary_multiplied_rgb[1], $secondary_multiplied_rgb[2]); // Transform the RGB values into a hexcode
	array_push($color_palette, $secondary_multiplied_hex);

	return $color_palette;

}

// Generate a palette using the Pride Flag Color algorithm
// With this algorith, a relationship between a given color and the center color of a given pride flag is calculated for each color, and then applied in reverse to the input color
function generatePrideColorPalette($color, $flag)
{

	global $pride_flags;
	$color_palette = [];

	// If the flag wasn't defined in the command, get the global default value
	if (!isset($flag)) {
		global $default_pride_flag;
		$flag = $default_pride_flag;
	}


	$flag_colors = $pride_flags[$flag];
	$number_of_colors = count($flag_colors);
	$center_color = hexToRGB($flag_colors[($number_of_colors - 1) / 2]);
	$input_color = hexToRGB($color);

	for ($i = 0; $i < $number_of_colors; $i++) {

		$current_color = hexToRGB($flag_colors[$i]);

		$new_color_rgb = [];

		// For each of the color channels
		for ($j = 0; $j < count($current_color); $j++) {

			// The value of change between the current color and the center color
			$delta = $center_color[$j] - $current_color[$j];

			// Apply the change relationship in reverse to the input color
			$new_channel = clampColorValue($input_color[$j] - $delta);

			array_push($new_color_rgb, $new_channel);

		}

		$new_color = sprintf("#%02x%02x%02x", $new_color_rgb[0], $new_color_rgb[1], $new_color_rgb[2]); // Transform the RGB values into a hexcode
		array_push($color_palette, $new_color);

	}

	return $color_palette;

}

// Generate the image for the color palette using GD
function createPaletteImage($interaction, $color, GenerationAlgorithms $generationAlgorithm, $number_of_colors)
{

	global $image_width, $image_height, $watermark_width, $watermark_position_x, $watermark_position_y, $text_color_switch_threshold;

	// Generate the appropriate palette
	$color_palette = match ($generationAlgorithm) {
		GenerationAlgorithms::DarkenLighten => generateDarkenLightenPalette($color, $number_of_colors),
		GenerationAlgorithms::ContrastingColor => generateContrastingColorPalette($color, $number_of_colors),
		GenerationAlgorithms::PrideFlag => generatePrideColorPalette($color, $interaction->data->options->offsetGet('pride_flag')->value)
	};

	$image = imagecreatetruecolor($image_width, $image_height);

	$number_of_colors = count($color_palette);

	$index = 0;
	foreach ($color_palette as &$hex) {

		$color_rgb = hexToRGB($hex);

		$background_color = imagecolorallocate($image, $color_rgb[0], $color_rgb[1], $color_rgb[2]);

		// Create the rectangle for the color
		$rectangle_width = $image_width / $number_of_colors;
		imagefilledrectangle($image, ($index * $rectangle_width), 0, (($index * $rectangle_width) + $rectangle_width), $image_height, $background_color);

		// Add the text with the color's hexcode
		// Text color is either white or black, depending on the sum of the rgb color values - dark colors will have a higher value and therefore should have white text
		$text_color = ($color_rgb[0] + $color_rgb[1] + $color_rgb[2] > $text_color_switch_threshold) ? imagecolorallocate($image, 0, 0, 0) : imagecolorallocate($image, 255, 255, 255);

		// Text should take up 90% of the rectangle ($rectangle_width * 0.9); that size needs to be converted from px to pts (* 0.75); and scaled down for the 7-letter code (/ 7)
		$font_size = ($rectangle_width * 0.9 * 0.75) / 7;

		imagettftext($image, $font_size, 0, (($index * $rectangle_width) + ($rectangle_width * 0.2)), ($image_height * 0.9), $text_color, './assets/fonts/RedHatMono.ttf', $hex);

		$index++;

	}
	unset($hex);

	// Apply the watermark
	$watermark_image = imagescale(imagecreatefrompng('./assets/watermark.png'), $watermark_width);
	$watermark_height = imagesy($watermark_image);
	imagecopy($image, $watermark_image, $watermark_position_x, $watermark_position_y, 0, 0, $watermark_width, $watermark_height);

	return $image;

}

// Check for errors in the input
function errorChecking($interaction, $number_of_colors)
{

	global $hex_regex, $short_hex_regex, $rgb_regex;
	global $error_messages;

	$color = $interaction->data->options->offsetGet('color')->value;

	// Number of colors has to be at least 3
	if ($number_of_colors < 3) {
		$interaction->respondWithMessage(MessageBuilder::new()->setContent(strtr($error_messages['low_number_of_colors'], array('{$number_of_colors}' => $number_of_colors))));
		return false;
	}

	// Number of colors has to be at most 21
	if ($number_of_colors > 21) {
		$interaction->respondWithMessage(MessageBuilder::new()->setContent(strtr($error_messages['high_number_of_colors'], array('{$number_of_colors}' => $number_of_colors))));
		return false;
	}

	// Number of colors has to be odd
	if ($number_of_colors % 2 == 0) {
		$interaction->respondWithMessage(MessageBuilder::new()->setContent(strtr($error_messages['even_number_of_colors'], array('{$number_of_colors}' => $number_of_colors))));
		return false;
	}

	// The color argument has to be in the correct format
	$correct_color_format = (
		preg_match($hex_regex, $color) ||
		preg_match($short_hex_regex, $color) ||
		preg_match($rgb_regex, $color)
	);

	if (!$correct_color_format) {
		$interaction->respondWithMessage(MessageBuilder::new()->setContent(strtr($error_messages['wrong_color_format'], array('{$color}' => $color))));
		return false;
	}

	// The RGB values have to be between 0 and 255
	if (preg_match($rgb_regex, $color)) {

		$color_rgb = explode(', ', rtrim(ltrim($color, 'rgb('), ')'));

		foreach ($color_rgb as $value) {
			if ($value < 0 || $value > 255) {
				$interaction->respondWithMessage(MessageBuilder::new()->setContent(strtr($error_messages['incorrect_rgb_range'], array('{$rgb_values}' => $color))));
				return false;
			}
		}
		unset($value);

	}

	return $interaction;

}

// Generate the embed and the Discord message with the color palette image
function generateColorMessage($interaction, GenerationAlgorithms $generationAlgorithm)
{

	global $discord;

	$id = $interaction->id;
	$color = $interaction->data->options->offsetGet('color')->value;
	$number_of_colors = $interaction->data->options->offsetGet('number_of_colors')->value;

	// If the number of colors wasn't defined in the command, get the global default value
	if (!isset($number_of_colors)) {
		global $number_of_colors;
	}

	if (!errorChecking($interaction, $number_of_colors)) {
		return;
	}

	$color = normalizeColorFormat($color);

	$image = createPaletteImage($interaction, $color, $generationAlgorithm, $number_of_colors);

	// The image is temporarily saved to a local file to be uploaded into the embed later
	imagepng($image, './palettes/' . $id . '.png');

	// Creating the embed
	$embed = $discord->factory(Embed::class);
	$embed->setDescription('Generating a palette for: `' . $color . '`')
		->setColor($color)
		->setImage('attachment://' . $id . '.png');

	// Adding the image file for the embed to use
	$interaction->respondWithMessage(
		MessageBuilder::new()
			->addFile('./palettes/' . $id . '.png', $id . '.png')
			->setEmbeds([$embed])
	);

	// Deleting the temporary file with the image
	unlink('./palettes/' . $id . '.png');

}

// Ran when the bot successfuly connects to Discord
$discord->on('ready', function (Discord $discord) {

	echo "Bot is ready!", PHP_EOL;

	createCommands(); // The createCommands function should only be ran if there are any changes to the commands that haven't been applied yet

	$discord->listenCommand('generate-dl', function (Interaction $interaction) {
		generateColorMessage($interaction, GenerationAlgorithms::DarkenLighten);
	});

	$discord->listenCommand('generate-con', function (Interaction $interaction) {
		generateColorMessage($interaction, GenerationAlgorithms::ContrastingColor);
	});

	$discord->listenCommand('generate-pride', function (Interaction $interaction) {
		generateColorMessage($interaction, GenerationAlgorithms::PrideFlag);
	});

});

// Run the bot
$discord->run();